// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for Status.
const (
	INTERNALERROR   Status = "INTERNAL_ERROR"
	INVALIDARGUMENT Status = "INVALID_ARGUMENT"
	NOTFOUND        Status = "NOT_FOUND"
	OK              Status = "OK"
)

// Attributes defines model for Attributes.
type Attributes map[string]string

// ContainerRegistry defines model for ContainerRegistry.
type ContainerRegistry struct {
	Id                 string     `json:"id"`
	Labels             []string   `json:"labels"`
	LastUpdateTime     string     `json:"lastUpdateTime"`
	RegistryAttributes Attributes `json:"registryAttributes"`
	RegistryType       string     `json:"registryType"`
	RegistryUrl        string     `json:"registryUrl"`
}

// ContainerRegistryResponse defines model for ContainerRegistryResponse.
type ContainerRegistryResponse struct {
	Registry      *ContainerRegistry `json:"registry,omitempty"`
	Status        Status             `json:"status"`
	StatusMessage string             `json:"statusMessage"`
}

// GitProject defines model for GitProject.
type GitProject struct {
	AccessToken    string   `json:"accessToken"`
	Id             string   `json:"id"`
	Labels         []string `json:"labels"`
	LastUpdateTime string   `json:"lastUpdateTime"`
	ProjectUrl     string   `json:"projectUrl"`
}

// GitProjectResponse defines model for GitProjectResponse.
type GitProjectResponse struct {
	Project       GitProject `json:"project"`
	Status        Status     `json:"status"`
	StatusMessage string     `json:"statusMessage"`
}

// SetupDatabaseRequest defines model for SetupDatabaseRequest.
type SetupDatabaseRequest struct {
	DbName          string `json:"dbName"`
	DbOemName       string `json:"dbOemName"`
	PluginName      string `json:"pluginName"`
	ServiceUserName string `json:"serviceUserName"`
}

// SetupDatabaseResponse defines model for SetupDatabaseResponse.
type SetupDatabaseResponse struct {
	Status        Status `json:"status"`
	StatusMessage string `json:"statusMessage"`
	VaultPath     string `json:"vaultPath"`
}

// Status defines model for Status.
type Status string

// PostSetupdatabaseJSONRequestBody defines body for PostSetupdatabase for application/json ContentType.
type PostSetupdatabaseJSONRequestBody = SetupDatabaseRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List of APIs provided by the service
	// (GET /api-docs)
	GetApiDocs(c *gin.Context)
	// Get container Registry by ID
	// (GET /containerregistry/{id})
	GetContainerRegistryById(c *gin.Context, id string)
	// Get git project details by ID
	// (GET /gitproject/{id})
	GetGitProjectById(c *gin.Context, id string)
	// Setup the database
	// (POST /setupdatabase)
	PostSetupdatabase(c *gin.Context)
	// Kubernetes readiness and liveness probe endpoint
	// (GET /status)
	GetStatus(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetApiDocs operation middleware
func (siw *ServerInterfaceWrapper) GetApiDocs(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetApiDocs(c)
}

// GetContainerRegistryById operation middleware
func (siw *ServerInterfaceWrapper) GetContainerRegistryById(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", c.Param("id"), &id)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetContainerRegistryById(c, id)
}

// GetGitProjectById operation middleware
func (siw *ServerInterfaceWrapper) GetGitProjectById(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", c.Param("id"), &id)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetGitProjectById(c, id)
}

// PostSetupdatabase operation middleware
func (siw *ServerInterfaceWrapper) PostSetupdatabase(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSetupdatabase(c)
}

// GetStatus operation middleware
func (siw *ServerInterfaceWrapper) GetStatus(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetStatus(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/api-docs", wrapper.GetApiDocs)
	router.GET(options.BaseURL+"/containerregistry/:id", wrapper.GetContainerRegistryById)
	router.GET(options.BaseURL+"/gitproject/:id", wrapper.GetGitProjectById)
	router.POST(options.BaseURL+"/setupdatabase", wrapper.PostSetupdatabase)
	router.GET(options.BaseURL+"/status", wrapper.GetStatus)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9RW34/iNhD+Vyy3j+mx177xxi3bFdo9QAH6clqtnHhgfU1sn2eChFb875WdHwRIgErb",
	"qn0DZ3593zee8TtPTW6NBk3Ih+8c0zfIRfg5InIqKQjCPyGlImW0yObOWHCkynPaWeBDjuSU3vB9VB+Y",
	"5Duk5A/ujSahNLgYNgrJ7bybPQqiZGeoTCSQlQYE+cV0wjmxK32QVlYKgqXKodPFVXUcA/zZwZoP+U+D",
	"AyGDio1By7LlvwyBLyRYuazjezD4USgHkg+/eezHHg3uMzCdpZ/U83KLAjGgNRrhXAnX0ugSI+ei7iOO",
	"JKi4SuaitGrsvwKi2MB1pqwzAVGT6DRCF/ZHRfPK7wysSFNAXJo/QXfq+O+2ZQXv9qZpOURHWPo76DJD",
	"/W1hDxRekrZF9n+0HRZAhR0LEolAiOFHAdjRGDKZih6VZDKDvPerzYqN0r2fEdxWpbBCcD02pxgP8dqp",
	"o7rC85A3gO4T+aP1ivhWFBnNBb1dR9qjYTtGJ7SmZtBF7gPNnnjEJ9PlQzwdPb8+xPEsDgd/jJ4n49dR",
	"/Lj6+jBd8ohPZ8vX32er6bgVuCnO3369NqEZAFOnrF9+fMjvhSXQbLQBTWxmQbP4YbFko/mEoYVUrVUq",
	"gmnESVEGl10WJy5bcFjm+fzp7tOdR2gsaGEVH/LfwlHEraC3AHkgrPpFmjT82UBoZC9oiDaRfMgfgUZW",
	"jb2Jp7tUPpj/end3Dm72FHTBIs+F3wH8WSExs/a1IrPObJUEyZIdozdgVesFl0FaL4R6gwzeldy3CjvO",
	"9AjEGhdWLxEfeTLm0TmKs33zZTcJM1A4kQOBQz789s6Vj+354RHX4YbV+7XuNHIFRNUzp6srX7p58rWC",
	"DkCEtVml2OA7Gn14Nv3tpdncxdBwV7S4SFnQYKOoGorXyd8oYpUxk0BCZdjP/mGu/x9p71hwt/Ldz1Ig",
	"HP1gldVgDQPVYAffYf6GK9PYnpI8N0iLo2gle4D0xcjdh3HRuf/2+3IaH/H/+Z/K2S/BvQNBIE906GCv",
	"JL8Z/X2jb1HvlOuTD4vwfloXGWvCnNTxVCTgNBAgcyCk0oDIhJYsU1sIf6wzCTDQ0hqlqUToh2R9TQr/",
	"tOMDvn/Z/xUAAP//5pdQ4XgNAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
